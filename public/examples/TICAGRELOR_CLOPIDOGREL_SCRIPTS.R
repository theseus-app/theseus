################################################################################
# CreateStrategusAnalysisSpecification.R
# Auto-generated by applying OHDSI Strategus Template to user-provided settings
# Detailed annotations are provided throughout for clarity.
################################################################################

renv::restore(prompt = FALSE) # Restore renv environment for all required R libraries

# Load libraries needed by this script
library(dplyr)
library(Strategus)
library(tibble)
library(ROhdsiWebApi)
library(CohortMethod)
library(FeatureExtraction)
library(Cyclops)
library(ParallelLogger)

# ---- Define Connection to ATLAS/WebAPI ----
baseUrl <- "https://atlas-demo.ohdsi.org/WebAPI" # Change this to your ATLAS URL if needed

# ---- 1. Cohort Definitions --------------------------------------------------

# NOTE: IDs for target, comparator, outcome, negative controls, and concept sets
# are left as 'NA' due to missing IDs in the specification. Fill these before running.

# Dummy IDs and names for illustration only:
targetCohortId     <- NA
targetCohortName   <- ""
comparatorCohortId <- NA
comparatorCohortName <- ""

# Outcome cohorts (can be 1 or more)
outcomeCohortList <- list(
  list(id = NA, name = "")
)

# Negative Control Concept Set
negativeControlConceptSetId <- NA
negativeControlConceptSetName <- ""

# Covariate Inclusion/Exclusion Concept Sets
conceptsToInclude <- list(
  list(id = NA, name = "")
)
conceptsToExclude <- list(
  list(id = NA, name = "")
)

# ---- 2. Export Cohort Definitions from ATLAS ----

# This retrieves all main and outcome cohorts from WebAPI.
# You must fill in the correct integer IDs for your use case.
mainCohortIds <- c(targetCohortId, comparatorCohortId, sapply(outcomeCohortList, function(x) x$id))

cohortDefinitionSet <- ROhdsiWebApi::exportCohortDefinitionSet(
  baseUrl = baseUrl,
  cohortIds = mainCohortIds,
  generateStats = TRUE
)

# Assign new numeric IDs for internal use (1: target; 2: comparator; 3+: outcome(s))
if (!all(is.na(mainCohortIds))) {
  cohortDefinitionSet[cohortDefinitionSet$cohortId == targetCohortId, "cohortId"] <- 1
  cohortDefinitionSet[cohortDefinitionSet$cohortId == comparatorCohortId, "cohortId"] <- 2
  # Assume first outcome gets 3, others 4, ...
  for (i in seq_along(outcomeCohortList)) {
    cohortDefinitionSet[cohortDefinitionSet$cohortId == outcomeCohortList[[i]]$id, "cohortId"] <- 2 + i
  }
}

# ---- 3. Negative Control Outcome Cohort Set ---------------------------------

# If a negative control concept set is specified, query and resolve it here
negativeControlOutcomeCohortSet <- NULL
if (!is.na(negativeControlConceptSetId)) {
  negativeControlOutcomeCohortSet <- ROhdsiWebApi::getConceptSetDefinition(
    conceptSetId = negativeControlConceptSetId,
    baseUrl = baseUrl
  ) %>%
    ROhdsiWebApi::resolveConceptSet(baseUrl = baseUrl) %>%
    ROhdsiWebApi::getConcepts(baseUrl = baseUrl) %>%
    dplyr::rename(outcomeConceptId = "conceptId",
                  cohortName = "conceptName") %>%
    dplyr::mutate(cohortId = dplyr::row_number() + 100) %>% # assign negative control cohortIds starting from 101
    dplyr::select(cohortId, cohortName, outcomeConceptId)
}

# ---- 4. Prepare Analysis Cohort DataFrames ----------------------------------

# Prepare outcome cohort table (assuming first outcome)
oList <- cohortDefinitionSet %>%
  dplyr::filter(.data$cohortId == 3) %>%
  dplyr::mutate(outcomeCohortId = cohortId, outcomeCohortName = cohortName) %>%
  dplyr::select(outcomeCohortId, outcomeCohortName) %>%
  dplyr::mutate(cleanWindow = 365)

# Target and Comparator - update the cohortId/names as appropriate
cmTcList <- tibble::tibble(
  targetCohortId = 1,
  targetCohortName = targetCohortName,
  comparatorCohortId = 2,
  comparatorCohortName = comparatorCohortName
)

# Covariates to Exclude or Include - if IDs are specified populate below
excludedCovariateConcepts <- tibble::tibble(
  conceptId = if (!is.na(conceptsToExclude[[1]]$id)) conceptsToExclude[[1]]$id else numeric(0),
  conceptName = if (!is.na(conceptsToExclude[[1]]$name)) conceptsToExclude[[1]]$name else character(0)
)
includedCovariateConcepts <- tibble::tibble(
  conceptId = if (!is.na(conceptsToInclude[[1]]$id)) conceptsToInclude[[1]]$id else numeric(0),
  conceptName = if (!is.na(conceptsToInclude[[1]]$name)) conceptsToInclude[[1]]$name else character(0)
)
# If more than one include/exclude, expand as above.

# ---- 5. Strategus Shared Resources/Modules -----------------------------------

# Shared: Cohort & negative control definitions
cgModuleSettingsCreator <- CohortGeneratorModule$new()
cohortDefinitionShared <- cgModuleSettingsCreator$createCohortSharedResourceSpecifications(cohortDefinitionSet)

negativeControlsShared <- NULL
if (!is.null(negativeControlOutcomeCohortSet)) {
  negativeControlsShared <- cgModuleSettingsCreator$createNegativeControlOutcomeCohortSharedResourceSpecifications(
    negativeControlOutcomeCohortSet = negativeControlOutcomeCohortSet,
    occurrenceType = "first",
    detectOnDescendants = TRUE
  )
}

cohortGeneratorModuleSpecifications <- cgModuleSettingsCreator$createModuleSpecifications(
  generateStats = TRUE
)

# CohortDiagnostics module settings
cdModuleSettingsCreator <- CohortDiagnosticsModule$new()
cohortDiagnosticsModuleSpecifications <- cdModuleSettingsCreator$createModuleSpecifications(
  cohortIds = cohortDefinitionSet$cohortId,
  runInclusionStatistics = TRUE,
  runIncludedSourceConcepts = TRUE,
  runOrphanConcepts = TRUE,
  runTimeSeries = FALSE,
  runVisitContext = TRUE,
  runBreakdownIndexEvents = TRUE,
  runIncidenceRate = TRUE,
  runCohortRelationship = TRUE,
  runTemporalCohortCharacterization = TRUE,
  minCharacterizationMean = 0.01
)

# ---- 6. CohortMethod Time Windows / TARs ------------------------------------

# Translate time-at-risk definitions from specs into a tibble
# Align parameters with 'createCreateStudyPopulationArgs'
timeAtRisks <- tibble::tibble(
  label = c(
    "TAR 1: Censor at observation end; stay in if switch or discontinue in 1st year",
    "TAR 2: 5-year time-at-risk window from index",
    "TAR 3: On-treatment risk window (post index to end of persistent exposure, 7-day gap allowed or end of record)"
  ),
  riskWindowStart = c(0, 0, 1),
  startAnchor = c("cohort start", "cohort start", "cohort start"),
  riskWindowEnd = c(365, 1825, 0),
  endAnchor = c("cohort start", "cohort start", "cohort end"),
  minDaysAtRisk = c(1, 1, 1)
)

# ---- 7. CohortMethod Study Periods ------------------------------------------

studyPeriods <- tibble::tibble(
  studyStartDate = c("20111101", "20130301"),
  studyEndDate =   c("20190331", "20161231")
)

# ---- 8. Propensity Score Adjustment Settings ---------------------------------

# PS Adjustment: as described in provided analysis specifications:
psSettingsList <- list(
  list(
    description = "PS 1: 1:1 greedy matching",
    matchOnPsArgs = list(maxRatio = 1, caliper = 0.2, caliperScale = "standardized logit"),
    stratifyByPsArgs = NULL
  ),
  list(
    description = "PS 2: Variable ratio matching (max 10:1)",
    matchOnPsArgs = list(maxRatio = 10, caliper = 0.2, caliperScale = "standardized logit"),
    stratifyByPsArgs = NULL
  ),
  list(
    description = "PS 3: Stratification by decile",
    matchOnPsArgs = NULL,
    stratifyByPsArgs = list(baseSelection = "all", numberOfStrata = 10)
  )
)

# ---- 9. CohortMethod cmAnalysisList Construction ----------------------------

cmAnalysisList <- list()
analysisId <- 1
targetComparatorOutcomesList <- list()

for (s in seq_len(nrow(studyPeriods))) {
  currStart <- studyPeriods$studyStartDate[s]
  currEnd   <- studyPeriods$studyEndDate[s]
  for (t in seq_len(nrow(timeAtRisks))) {
    tar <- timeAtRisks[t,]
    for (p in seq_along(psSettingsList)) {
      psSet <- psSettingsList[[p]]
      
      # Build matchOnPsArgs or stratifyByPsArgs per current PS configuration
      matchOnPsArgs <- if (!is.null(psSet$matchOnPsArgs)) {
        CohortMethod::createMatchOnPsArgs(
          maxRatio     = psSet$matchOnPsArgs$maxRatio,
          caliper      = psSet$matchOnPsArgs$caliper,
          caliperScale = psSet$matchOnPsArgs$caliperScale
        )
      } else NULL
      
      stratifyByPsArgs <- if (!is.null(psSet$stratifyByPsArgs)) {
        CohortMethod::createStratifyByPsArgs(
          numberOfStrata     = psSet$stratifyByPsArgs$numberOfStrata,
          baseSelection      = psSet$stratifyByPsArgs$baseSelection
        )
      } else NULL
      
      covariateSettings <- FeatureExtraction::createDefaultCovariateSettings(
        addDescendantsToExclude = TRUE
      )
      
      # Compose list of outcomes (includes negative controls if specified)
      outcomeList <- list()
      for (i in seq_len(nrow(oList))) {
        outcomeList <- append(outcomeList, list(
          CohortMethod::createOutcome(
            outcomeId = oList$outcomeCohortId[i],
            outcomeOfInterest = TRUE,
            trueEffectSize = NA,
            priorOutcomeLookback = 99999
          )
        ))
      }
      if (!is.null(negativeControlOutcomeCohortSet)) {
        for (i in seq_len(nrow(negativeControlOutcomeCohortSet))) {
          outcomeList <- append(outcomeList, list(
            CohortMethod::createOutcome(
              outcomeId = negativeControlOutcomeCohortSet$cohortId[i],
              outcomeOfInterest = FALSE,
              trueEffectSize = 1
            )
          ))
        }
      }
      
      # Compose TCO object
      targetComparatorOutcomesList[[analysisId]] <- CohortMethod::createTargetComparatorOutcomes(
        targetId = cmTcList$targetCohortId[1],
        comparatorId = cmTcList$comparatorCohortId[1],
        outcomes = outcomeList,
        excludedCovariateConceptIds = if (nrow(excludedCovariateConcepts) > 0) excludedCovariateConcepts$conceptId else c()
      )
      
      # CohortMethod data arguments
      getDbCohortMethodDataArgs <- CohortMethod::createGetDbCohortMethodDataArgs(
        restrictToCommonPeriod = FALSE, # per 'createStudyPopArgs'
        studyStartDate = currStart,
        studyEndDate = currEnd,
        maxCohortSize = 0,
        covariateSettings = covariateSettings
      )
      
      # PS fitting settings
      createPsArgs <- CohortMethod::createCreatePsArgs(
        maxCohortSizeForFitting = 250000,
        errorOnHighCorrelation = TRUE,
        prior = Cyclops::createPrior(
          priorType = "laplace",
          useCrossValidation = TRUE
        ),
        control = Cyclops::createControl(
          tolerance = 2e-7,
          cvType = "auto",
          fold = 10,
          cvRepetitions = 10,
          noiseLevel = "silent",
          resetCoefficients = TRUE,
          startingVariance = 0.01
        )
      )
      
      # Covariate balance args
      computeSharedCovariateBalanceArgs <- CohortMethod::createComputeCovariateBalanceArgs(
        maxCohortSize = 250000,
        covariateFilter = NULL
      )
      computeCovariateBalanceArgs <- CohortMethod::createComputeCovariateBalanceArgs(
        maxCohortSize = 250000,
        covariateFilter = FeatureExtraction::getDefaultTable1Specifications()
      )
      
      # Outcome model arguments
      fitOutcomeModelArgs <- CohortMethod::createFitOutcomeModelArgs(
        modelType = "cox",
        stratified = FALSE,
        useCovariates = FALSE,
        inversePtWeighting = FALSE,
        prior = Cyclops::createPrior(
          priorType = "laplace",
          useCrossValidation = TRUE
        ),
        control = Cyclops::createControl(
          tolerance = 2e-7,
          cvType = "auto",
          fold = 10,
          cvRepetitions = 10,
          noiseLevel = "quiet",
          resetCoefficients = TRUE,
          startingVariance = 0.01
        )
      )
      
      # Study Population arguments
      createStudyPopArgs <- CohortMethod::createCreateStudyPopulationArgs(
        restrictToCommonPeriod = FALSE,
        firstExposureOnly = FALSE,
        washoutPeriod = 0,
        removeDuplicateSubjects = "keep all",
        censorAtNewRiskWindow = FALSE,
        removeSubjectsWithPriorOutcome = TRUE,
        priorOutcomeLookback = 99999,
        riskWindowStart = tar$riskWindowStart,
        startAnchor = tar$startAnchor,
        riskWindowEnd = tar$riskWindowEnd,
        endAnchor = tar$endAnchor,
        minDaysAtRisk = tar$minDaysAtRisk
      )
      
      # Add the CohortMethod analysis to the list
      cmAnalysisList[[analysisId]] <- CohortMethod::createCmAnalysis(
        analysisId = analysisId,
        description = sprintf(
          "SP: %s-%s; TAR: %s; PS: %s",
          currStart, currEnd, tar$label, psSet$description
        ),
        getDbCohortMethodDataArgs = getDbCohortMethodDataArgs,
        createStudyPopArgs = createStudyPopArgs,
        createPsArgs = createPsArgs,
        matchOnPsArgs = matchOnPsArgs,
        stratifyByPsArgs = stratifyByPsArgs,
        computeSharedCovariateBalanceArgs = computeSharedCovariateBalanceArgs,
        computeCovariateBalanceArgs = computeCovariateBalanceArgs,
        fitOutcomeModelArgs = fitOutcomeModelArgs
      )
      analysisId <- analysisId + 1
    }
  }
}

# ---- 10. Assemble CohortMethodModule Specifications --------------------------

cmModuleSettingsCreator <- CohortMethodModule$new()
cohortMethodModuleSpecifications <- cmModuleSettingsCreator$createModuleSpecifications(
  cmAnalysisList = cmAnalysisList,
  targetComparatorOutcomesList = targetComparatorOutcomesList,
  analysesToExclude = NULL,
  refitPsForEveryOutcome = FALSE,
  refitPsForEveryStudyPopulation = FALSE,
  cmDiagnosticThresholds = CohortMethod::createCmDiagnosticThresholds()
)

# ---- 11. Compose Analysis Specifications -------------------------------------

# Start with empty analysis specification object
analysisSpecifications <- Strategus::createEmptyAnalysisSpecificiations()

# Add shared resources
analysisSpecifications <- Strategus::addSharedResources(analysisSpecifications, cohortDefinitionShared)
if (!is.null(negativeControlsShared)) {
  analysisSpecifications <- Strategus::addSharedResources(analysisSpecifications, negativeControlsShared)
}

# Add CohortGenerator, Diagnostics and CohortMethod module settings
analysisSpecifications <- Strategus::addModuleSpecifications(analysisSpecifications, cohortGeneratorModuleSpecifications)
analysisSpecifications <- Strategus::addModuleSpecifications(analysisSpecifications, cohortDiagnosticsModuleSpecifications)
analysisSpecifications <- Strategus::addModuleSpecifications(analysisSpecifications, cohortMethodModuleSpecifications)

# ---- 12. Save as JSON to disk ------------------------------------------------
# Use placeholder study name as path; override for your project/study.

outPath <- file.path("inst", "studyName")
outFile <- file.path(outPath, "studyNameAnalysisSpecification.json")

if (!dir.exists(outPath)) {
  dir.create(outPath, recursive = TRUE)
}

ParallelLogger::saveSettingsToJson(
  analysisSpecifications,
  outFile
)

# ---- END SCRIPT --------------------------------------------------------------
# NOTE: Update all NA IDs/names with actual cohort/concept set details before use.
# All parameter choices and how they're used are annotated inline above.